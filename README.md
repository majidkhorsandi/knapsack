# About
This is a test project to test an implementation of knapsack algorithm developed to optimize the revenue from advertisement campaigns a company can sell to customers.

#Test Strategy
The project under test is a webservice written in Java. The test strategy is based on the levels of testing:
##1- Unit tests:
Project was lacking any unit tests, so first step was to implement unit tests for public methods of classes. Unit tests are implemented for all classes except Bookings. 
##2- Function tests (testing knapsack algorithm):
The class that implements knapsack algorithm is called Bookings.java. This is basically the core of what this webservice
does and had the highest priority from the testing perspective. The strategy used to test this class was to compare it
against another implementation of knapsack algorithm. Therefore another version of knapsack was implemented and tested
to be used as a reference. So results from algorithm under test were compared to results from alternative implementation.
A challenge here was to provide both algorithms with random test data and to solve it, a RandomCustomerGenerator class
was created that can generate a single random customer and/or a list of random customers. The constructor of this class
gets maximum impressions and maximum revenue a customer can have a generates a random customer with a
random name (generated by another class called RandomStringGenerator), a
random impression between 0 and maximum, and also a random revenue between 0 and provided maximum amount.
 Functional test of Bookings class is implemented inside BookingsTest class. This test class together with other unit test
 classes are put inside a TestNG xml suite file. The main benefit with this is that we can avoid hard-coding parameters
 needed for testing and the user of tests is able to change the parameters to run different tests with different number of
  customers, different max impression and max revenue and different available impressions. Here is how parameters look for
  BookingTest class:

  <parameter name="inventory" value="5000000" ></parameter>
  <parameter name="numberOfCustomers" value="6" ></parameter>
  <parameter name="maxImpressions" value="5000000"></parameter>
  <parameter name="maxRevenue" value="5000000"></parameter>
  <parameter name="customerFile value="customers2""></parameter>

So if one needs to run the test with different parameters it's just to edit this file. The last parameter (customerFile)
gives us the power to run tests using a given json file instead of creating random input. If this parameter is removed
or were commented out then the test will detect the file is missing and instead generates random test data.

##3- Load and performance tests
Its always good to test a web-service for performance, robustness and stability. In this case performance of service can
 be affected in several ways, e.g by providing it with a very big input which, by providing it with a normal input but by
 multiple clients at the same time or a combination, etc. Based on this a few tests are created using SoapUI tool:
  ###3-1 Performance test
  Putting service under a medium pressure with relatively low number of threads giving a normal input to the service. In this
   scenario, depending on the system we are running on we can expect a response time under a certain limit and also no crash
   or instability from the service.
  ###3-2 Robustness test
  Putting service under a very high pressure within a short time (a burst time) expecting it not to crash.

Other types of tests could also be performed for example a stability test that puts the service under a relatively high pressure
for a longer period of time and keeping an eye on the memory leaks, crashes, etc...

##4- Exploratory testing
Last but not least the important exploratory testing. This part is done by testing the service manually with different kind
 of expected and unexpected inputs. List of test cases performed manually (x={Inventory, customer's impression, customers revenue}):
 1- Test with a very big x (500000000)
 2- Test with a non-numeric x
 3- Test with a negative x
 4- Test with an empty x
 5- Test with a rather big input (300 customers)
 6- Test with duplicated customer name

# Bugs(defects) and observations

##1 Bugs
The potential bugs found under testing were found with exploratory testing

### 1-1 Application crashes due to insufficient memory when too big inventory is given.

### Manifestation
Application crashes.

#### Frequency
Always if the same input is given
#### How to reproduce
Use following input:
- Inventory = 500000000
- Customers
{
  "customers":[
     {
        "name":"CustomerA",
        "impressions":3258035,
        "revenue":26
     },
     {
        "name":"CustomerB",
        "impressions":4788954,
        "revenue":29
     }
  ]
}

This should be reproducable with any arbitrary customers input but same inventory amount.

#### Possible solution
Allocate enough memory for the application in case highest possible amount is entered or otherwise put a criteria on the
 maximum amount user can give as inventory

###1-2 Internal server error (java.lang.NullPointerException)
The service will return Internal server error caused by a NullPointerException in case /booking end point is called without
 an inventory e.g : http://the-service/booking

### Manifestation
Internal server error coming form NullPointerException but application does not crash

#### Frequency
Always if the same input is given

#### How to reproduce
Call the service's /booking endpoint without an inventory parameter and any normal customer json like:
{
  "customers":[
     {
        "name":"CustomerA",
        "impressions":3258035,
        "revenue":26
     },
     {
        "name":"CustomerB",
        "impressions":4788954,
        "revenue":29
     }
  ]
}

#### possible solution
Check for null inventory

###1-3 Internal server error (NegativeArraySizeException)
Service will return internal server error if a negative inventory is given

### Manifestation
Internal server error coming form NegativeArraySizeException but application does not crash.

#### Frequency
Always if the same input is given

#### How to reproduce
Call the service's /booking endpoint with a negative inventory value smaller than -1 and normal customer json like:
{
  "customers":[
     {
        "name":"CustomerA",
        "impressions":3258035,
        "revenue":26
     },
     {
        "name":"CustomerB",
        "impressions":4788954,
        "revenue":29
     }
  ]
}

#### possible solution
Add a check to make sure inventory is always > 0;

###1-4 Internal server error (ArrayIndexOutOfBoundsException)
Service will return internal server error if a customer with negative impression is given.

### Manifestation
Internal server error coming form ArrayIndexOutOfBoundsException but application does not crash.

#### Frequency
Always if the same input is given

#### How to reproduce
Call the service's /booking endpoint with a positive inventory and a customer that has negative impression like:
{
  "customers":[
     {
        "name":"CustomerA",
        "impressions":-3258,
        "revenue":26
     },
     {
        "name":"CustomerB",
        "impressions":4788954,
        "revenue":29
     }
  ]
}

#### possible solution
Add a check to make sure customers impressions are always >= 0;

##2 Observations
After running BookingTest automatically for several time, an interesting case was observed were two algorithms found the
same optimized revenue but using different combination of customers and hence different total number of impressions. The
algorithm under test reached the same revenue by picking smaller impressions. If we can reach the same revenue, isn't it
better to handle more impressions?
An example test data that can reproduce this case:
{
  "customers":[
     {
        "name":"CustomerA",
        "impressions":3258035,
        "revenue":26
     },
     {
        "name":"CustomerB",
        "impressions":4788954,
        "revenue":29
     },
     {
        "name":"CustomerC",
        "impressions":5975402,
        "revenue":2
     },
     {
        "name":"CustomerD",
        "impressions":4603949,
        "revenue":23
     },
     {
        "name":"CustomerE",
        "impressions":377169,
        "revenue":3
     }
  ]
}

result:
Expected Impressions : 49994702
Actual   Impressions : 49897835


#How to run
To run unit tests and functional test maven can be used. Once under the project directory (where the pom.xml file is) run:
`mvn clean test -DsuiteXmlFile=<testSuiteFileName.xml>`

example:
mvn clean test -DsuiteXmlFile=OoyalaTestSuite.xml

note: to run any maven phase after the test phase, the switch "suiteXmlFile" should be used.

To run load and performance tests SoapUI is needed. Once SoapUI is installed, import the project xml file under "SoapUI-Tests"
, open test suite, test cases and run them. SoapUI's loadtestrunner.sh can also be used to run load tests.

#Tools used
TestNG (for automated tests)
SoapUI (for performance testing)
PMD (to check code)
Maven (for dependency management)
http://beta.json-generator.com/Nyf1W_xMg (to generate random input for manual testing)

